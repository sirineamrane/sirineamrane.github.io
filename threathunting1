threat hunting part 1 : persistance du malware par masquerading, 31 août 2025

bonjour à toutes et tous.
la persistance la plus insidieuse réside souvent dans la réappropriation de techniques d'évasion éprouvées. je parle ici du masquerading. cette méthode repose sur le renommage ou l'imitation de fichiers système reconnus afin de se fondre dans la masse et imiter des processus légitimes.
ici, l'analyse porte sur un cas d'attaque pour déployer un outil RMM (remote monitoring and management).
toutes les captures de l'article proviennent du logiciel Huntress, qui est un EDR, ou plus précisément un MDR, une plateforme qui détecte les menaces persistantes via signatures comportementale et reconstitue la chaîne d'attaque, de la persistance à l'exfiltration.
dissection : de la persistance passive à l'exfiltration active
le cycle de cette infection se déroule en deux phases distinctes, chacune ayant un rôle bien précis dans une chaine d'exécution bien orchestrée : trois artefacts de code distincts mais liés : vnetlib.exe, vmsvcore.exe et mimikatz.exe.
appelons-les "les agents dormants" et "le collecteur agressif"
phase I : les agents dormants, "vntlib.exe" et"msvcore.exe"
ce ne sont des binaires, l'un est légitime, l'autre est renommé, mais tous deux sont des éléments de redondance et résilience à visée malveillante . dans cet exemple, les deux se situent dans le répertoire d'installation de VMware (C:\Program Files (x86)\VMware\VMware Workstation\)
la persistance 1 : le service Vmware network install pointe vers vnetlib.exe, qui est le premier point d'ancrage, conçu ainsi pour s'exécuter au démarrage du système et permettre potentiellement de lancer d'autres actions malveillantes par la suite. celui-ci est un vrai exécutable, donc légitime, de VMware,
la persistance 2 : la tâche planifiée Vmware Tools Core Service pointe vers msvcore.exe, qui est le point de persistance, concu ainsi pour s'éxecuter à un moment précis ou de manière récurrente
son positionnement dans C:\Program Files (x86)\VMware\ n'est pas anodin et le choix du nom est une technique de typosquatting appliquée à des fichiers système, dont le but est le mimétisme de composants réels, ici sa ressemblance avec msvcr*.dll ou mscore.dll, qui sont des composants microsoft (msv pou microsoft visual). si un EDR n'est pas configuré pour analyser chaque processus avec une grande rigueur, ils passeront inaperçus

pourquoi l'attaquant en utiliserait deux ?
si un mécanisme est détecté et supprimé par un EDR, l'attaquant a toujours un autre point d'entrée pour maintenir son accès. c'est une technique courante de post-exploitation.
on peut estimer ses techniques d'évasion probables qui ont permis d'éliminer d'emblée les méthodes basiques et survivre des années passivement :
a) du fork bombing : c'est une méthode de dispersion, le processus malveillant se duplique rapidement, créant un grand nombre de processus inoffensifs qui submergent et ralentissent l'anti-malware, l'empêchant de se concentrer sur le processus malveillant. c'est une sorte de denial of service mais interne.
b) une injection de code process hollowing : c'est une méthode d'évasion extrêmement courante, au lieu de de s'exécuter comme un nouveau processus indépendant, l'attaquant manipule la création d'un thread au sein d'un processus déjà existant, c'est-à-dire que le code malveillant est injecté dans l'espace mémoire d'un thread d'un processus légitime, comme explorer.exe ou svchost.exe. ainsi, de l'extérieur, il n'y a pas de processus suspect à signaler, car l'activité malveillante est masquée au sein d'un processus reconnu. pour réaliser l'injection, l'attaquant vide au préalable la mémoire du nouveau processus puis utilise des appels de fonctions bas niveau comme NtCreateUserProcess et NtResumeThread car ce sont des appels peu documentés et peu logués par les anti-malware traditionnels. un attaquant ne passera rarement par des appels d'API comme CreateProcess qui sont plus haut-niveau et donc bien trop surveillées.
création du process parent suspendu : l'attaquant utilise l'appel API bas niveau NtCreateUserProcess pour lancer en mode suspendu le processus légitime qu'il choisit (le plus souvent un binaire de l'OS, comme svchost.exe). cela signifie que le processus est crée, ses structures de données sont bien allouées en mémoire, MAIS son thread principal ne s'exécute pas encore, il est dans un état suspendu. c'est la différence clé avec un simple CreateProcess, qui lancerait immédiatement le processus.
vidage de la mémoire : l'attaquant appelle des fonctions d'écriture en mémoire comme NtWriteVirtualMemory, qui écrase le binaire légitime en mémoire par un contenu par des zéros. la mémoire du processus est maintenant prête à être remplie
injection de la charge utile malveillante : l'attaquant alloue une nouvelle section de mémoire dans le processus maintenant vide et y injecte sa charge utile malveillante
modification du point d'entrée du thread principal : l'attaquant ponte en suite l'entrée vers l'adresse mémoire du code malveillant fraîchement injecté
reprise de l'exécution : l'attaquant utilise NtResumeThread pour dé-suspendre le thread principal, l'os pense qu'il exécute le binaire légitime, mais en réalité, le thread démarre l'exécution du code malveillant.

son but in fine étant de maintenir une socket ouverte (porte dérobée), d'attendre des instructions et d'assurer une persistance système via une tâche planifiée, comme ici le montre le screenshot :
phase II : le collecteur agressif, "mimikatz.exe"
l'alerte dans les logs n'a pas été déclenchée par l'agent dormant, mais par ce second binaire. ce mimikatz.exe st un exécutable temporaire, probablement téléchargé à partir du C2 (centre de contrôle) contrôlé par le premier binaire. c'est le moment où l'attaquant, ayant patienté x temps, décide d'agir via la backdoor, lui permettant via un protocole standard par exemple comme HTTPS de se fondre dans le trafic réseau légitime, et d'exécuter de nouvelles commandes, télécharger de nouvelles charges utiles, comme ici mimikatz.exe, qui fait donc d'office de module de collecte de données et plus tard, d'exfiltration.
son exécution a provoqué une alerte dans les logs de l'EDR, montrant une chaîne de commandes explicites.
l'éxécutable, qui se trouve dans le dossier "load" sur le dekstop de l'utilisateur est mimikatz.
pour les plus novices, mimikatz est un outil open-source crée par benjamin delpy pour établir une preuve de concept et montrer à microsoft que ses protocoles d'authentification étaient vulnérables aux attaques. sans le vouloir, il a créé un des outils de piratage les plus largement utilisés et téléchargés au cours des 20 dernières années.
parent PID "10464": l'image montre que le parent PID c'est-à-dire le processus parent est 10464, en regardant le processus qui a ce PID, on peut voir que c'est cmd.exe. cela indique bien que l'attaquant a utilisé une invite de commande pour lancer mimikatz. c'est une information importante qui complète la chaîne d'exécution
users "NT AUTHORITY\SYSTEM" : l'image montre que mimikatz s'exécute avec les privilèges de NT AUTHORITY\SYSTEM. c'est le compte de service le plus puissant sur un système windows. cela confirme que l'escalade de privilèges a réussi
voici maintenant les commandes mimikatz déclenchées par l'attaquant sur le cmd :
a) log : ce module sert à enregistrer la sortie de toutes les commandes suivantes dans un fichier texte, pour ne pas perdre les hash volés, même si la session mimikatz est fermée
b) privilege::debug : cette commande demande à windows d'activer le mode débogage pour le processus mimikatz, c'est CRUCIAL ici car le mode debug permet à l'éxécutable d'accéder à des processus sytèmes critiques, comme LSASS, qui gère les identifiants de connexion en mémoire comme nous l'avons déjà dit. sans ce privilège, les instructions ne marcheraient pas.
c) sekurlsa::logonpasswords : la commande célèbre de mimikatz
sekurlsa : c'est le module qui intéragit avec le processus LSASS
logonpasswords : c'est la sous-commande qui extrait les informations d'authentification des utilisateurs connectés, qui sont temporairement stockées en mémoire. c'est ce que l'attaquant cherche (hachages NTLM, parfois mots de passe en clair)

d) token::elevate : une commande puissante qui permet à un attaquant d'obtenir un niveau de privilège élevé sur un système Windows. Après avoir acquis le privilège de débogage, cette commande cible les tokens d'authentifications des sessions actives pour les manipuler. le processus se déroule comme suit : 1- la recherche de tokens : mimikatz parcourt la mémoire pour trouver les jetons de sécurité appartenant à d'autres processus qui s'exécutent avec des privilèges élevés, comme les services système ou les processus administratifs. 2- l'usurpation d'identité : une fois qu'un jeton à haut niveau de privilège est trouvé, mimikatz le "vole" et se l'attribue. 3-élévation de privilèges : en utilisant le token volé, mimikatz élève ses propres privilèges au niveau le plus élevé, soit NT AUTHORITY\SYSTEM. 4- accès aux ressources critiques : l'attaquant dispose alors d'un accès total à la machine. il peut désormais interagir avec des processus protégés comme lsass.exe, qui gère les informations d'authentification, pour voler les identifiants stockés en mémoire. c'est ce qui permet de "dumper" la mémoire de LSASS pour récupérer les mots de passe et les hachages, une étape essentielle pour le mouvement latéral sur le réseau.
e) lsadump::sam : la commande montre une intention ciblée sur la base de données SAM (Security Account Manager). cette commande vise à extraire les hashes de mots de passe de la base de données SAM de Windows et les réutiliser. une technique relativement classique.
lsadump : lsadump est un module qui sert à extraire des informations du processus LSASS (local security authority subsystem service), un composant vital de Windows qui gère les politiques de sécurité locales
sam : sous-commande qui cible la base la base de données SAM qui stocke les mots de passe hachés des comptes utilisateurs locaux.

f) exit : la commande termine et ferme le programme mimikatz
la capture montre une chronologie des événements qui relie la persistance du logiciel malveillant à l'exfiltration active. elle confirme la chronologie de l'attaque et ajoute une découverte majeure : l'attaquant a effacé les journaux de sécurité.
confirmation du masquerading : la nouvelle image indique explicitement : "Discovered Persistence Masquerading as Legitimate VMware Tools", valide l'hypothèse de départ et confirme que le "masquerading" était bien la technique d'attaque principale
chronologie de l'attaque : la persistance a été "découverte" le 14 août 2025 à 22h03. cela confirme que le logiciel malveillant était présent depuis longtemps. la tentative d'exfiltration avec mimikatz a eu lieu quelques minutes plus tard, à 22h09
nettoyage après l'attaque : l'information la plus précieuse est l'événement du 15 août 2025 à 00h05 : "Clearing of Security Event Logs". c'est une tactique classique de post-exploitation utilisée pour masquer des traces et compliquer l'analyse forensique.

la conclusion : les solutions statiques sont bien obsolètes
cette attaque nous rappelle une fois de plus que les défenses basées sur les signatures statiques sont en retard d'une guerre. la détection de mimikatz.exe n'est pas une victoire du système, mais la reconnaissance que l'attaque est passée en mode offensif. la vraie menace, vmsvcore.exe, avait déjà eu le temps d'établir son point d'ancrage mais l'EDR a détecté cette persistance. c'est là que réside l'importance d'une approche de threat hunting qui se base mais sur la chaîne d'appels syscalls.
la résilience de la défense ne se mesure pas au nombre de menaces que nous bloquons à la signature, mais à la capacité à identifier l'intention malveillante, même si elle est enveloppée dans un plus grand engrenage et une large couche de légitimité.
